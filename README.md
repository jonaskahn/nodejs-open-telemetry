# Service and Cronjob Demo

[Vietnamese](https://www.youtube.com/watch?v=dQw4w9WgXcQ)

> Generated by Claude AI

This project demonstrates a JavaScript application with 5 services and 2 cronjobs using CommonJS modules. The services
call each other and the cronjobs utilize these services to perform scheduled tasks. It also includes OpenTelemetry
instrumentation for monitoring function calls.

## Project Structure

```
├── src/
│   ├── services/           # Service modules
│   │   ├── userService.js  # User management
│   │   ├── dataService.js  # Data operations
│   │   ├── notificationService.js  # Notifications
│   │   ├── loggingService.js  # Logging
│   │   └── authService.js  # Authentication
│   ├── jobs/               # Cronjob modules
│   │   ├── dataBackupJob.js  # Backup job (with OpenTelemetry)
│   │   └── reportGenerationJob.js  # Report generation job
│   ├── middleware/
│   │   └── telemetry.js    # OpenTelemetry configuration
│   └── index.js            # Application entry point
├── docker-compose.yml      # Docker configuration for Jaeger
└── package.json
```

## Services

1. **User Service** - Manages user-related operations
2. **Data Service** - Handles data operations and storage
3. **Notification Service** - Sends notifications to users
4. **Logging Service** - Provides logging functionality
5. **Auth Service** - Handles authentication and authorization

## Cronjobs

1. **Data Backup Job** - Runs daily at 2:00 AM to create data backups (Instrumented with OpenTelemetry)
2. **Report Generation Job** - Runs every Monday at 8:00 AM to generate weekly reports

## Getting Started

### Starting Jaeger for Telemetry Visualization

Before running the application, start the Jaeger container:

```bash
docker-compose up -d
```

This will start Jaeger at http://localhost:16686

### Installation

```bash
npm install
```

### Running the Application

```bash
npm start
```

After running the application, you can see the OpenTelemetry traces in the Jaeger UI at http://localhost:16686.

## Integrating OpenTelemetry Into Your NodeJS Project

This section provides guidelines for implementing tracing in your existing Node.js application.

### Setting Up OpenTelemetry

1. **Install the required packages**:

   ```bash
   npm install @opentelemetry/api @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node @opentelemetry/exporter-trace-otlp-http @opentelemetry/resources @opentelemetry/semantic-conventions
   ```

2. **Configure OpenTelemetry in your project**:
   - Use the `telemetry.js` middleware as a reference
   - Initialize the SDK with your service name and version
   - Configure the exporter to send traces to your backend (Jaeger, Zipkin, etc.)

### Converting Regular Methods to Traced Methods

To add tracing to existing methods, follow these patterns:

#### Basic Method Tracing

```javascript
// Before: Regular method
function myFunction(param1, param2) {
  // Function implementation
  return result;
}

// After: Method with tracing
function myFunction(param1, param2) {
  return telemetry.wrapWithSpan('myFunction', { param1, param2 }, async () => {
    // Function implementation
    return result;
  });
}
```

#### Maintaining Trace Context with Nested Functions

To maintain the parent-child relationship in traces when using nested function calls:

```javascript
// Parent function with tracing
function parentFunction(params) {
  return telemetry.wrapWithSpan('parentFunction', { params }, async () => {
    // Call preparation logic
    const result1 = await _childFunction1();
    const result2 = await _childFunction2(result1);
    return result2;
  });
}

// Child function 1 with tracing - maintains the same trace
function _childFunction1() {
  return telemetry.wrapWithSpan('_childFunction1', {}, async () => {
    // Implementation
    return result;
  });
}

// Child function 2 with tracing - maintains the same trace
function _childFunction2(input) {
  return telemetry.wrapWithSpan('_childFunction2', { input }, async () => {
    // Implementation
    return result;
  });
}
```

### Best Practices for Hierarchical Tracing

1. **Use Consistent Naming Conventions**:

   - Use descriptive span names that reflect the operation being performed
   - Prefix internal/private functions with underscore (\_) to identify them in traces

2. **Add Relevant Attributes to Spans**:

   - Include function parameters as span attributes for better context
   - Exclude sensitive information like passwords or tokens
   - Add operation-specific attributes (e.g., user IDs, task IDs)

3. **Error Handling in Spans**:

   ```javascript
   function myFunction(params) {
     return telemetry.wrapWithSpan('myFunction', { params }, async span => {
       try {
         // Implementation
         return result;
       } catch (error) {
         // Record error in the span
         span.setStatus({
           code: SpanStatusCode.ERROR,
           message: error.message,
         });
         // You can also add error details as attributes
         span.setAttribute('error.type', error.name);
         span.setAttribute('error.stack', error.stack);
         throw error; // Re-throw the error
       }
     });
   }
   ```

4. **Execution IDs for Correlation**:
   - Generate a unique ID for each top-level operation
   - Pass this ID through the entire call chain
   - Add it as an attribute to all spans for easy correlation

### Real-World Example: Job with Nested Traces

See the implementation in `src/jobs/reportGenerationJob.js` and `src/jobs/dataBackupJob.js` for complete examples of
hierarchical tracing with multiple levels of nested function calls.

The `notificationService.js` file demonstrates a complex service with 5 levels of nested calls, all properly traced with
OpenTelemetry.

## OpenTelemetry Instrumentation

This project demonstrates OpenTelemetry usage for the following:

1. **Function call tracing** - The Data Backup Job is instrumented to trace all function calls
2. **Span attributes** - Various attributes are added to spans to provide context
3. **Error tracking** - Errors are properly recorded in spans

## How it Works

The services are designed to work together:

- **User Service** uses Auth Service to verify user access and Logging Service to log operations
- **Data Service** uses Notification Service to send updates and Logging Service to log operations
- **Notification Service** uses Logging Service to track notifications
- **Auth Service** uses Logging Service to log authentication events

The cronjobs demonstrate scheduled tasks:

- **Data Backup Job** uses Data Service to create backups and Notification Service to send alerts
- **Report Generation Job** uses User Service and Data Service to gather data, then Notification Service to send the
  report

## Testing

For testing purposes, you can modify the cronjob schedules in their respective configuration objects:

- In `src/jobs/dataBackupJob.js`, update the `CONFIG.schedule` value to run more frequently
- In `src/jobs/reportGenerationJob.js`, update the `CONFIG.schedule` value to run more frequently

## Design Principles

This project demonstrates:

1. Modular design with CommonJS exports
2. Function-based implementation (no classes)
3. Service dependencies and cross-service calls
4. Scheduled tasks via cronjobs
5. OpenTelemetry instrumentation for observability

### Converting Existing Nested Methods While Maintaining Span Context

When integrating OpenTelemetry into an existing codebase with deeply nested method calls, follow these steps to maintain
proper span context:

#### Before: Original Nested Methods

```javascript
// Original code with nested method calls
function processOrder(order) {
  validateOrder(order);
  const items = prepareItems(order.items);
  const payment = processPayment(order.payment);
  const shipment = arrangeShipping(items, order.address);
  sendConfirmation(order.customer, shipment);
  return { orderId: order.id, status: 'completed' };
}
```

#### After: Traced Nested Methods

```javascript
// Primary function with tracing
function processOrder(order) {
  const executionId = uuid.v4(); // Generate unique execution ID

  return telemetry.startActiveSpan(
    'processOrder',
    {
      attributes: {
        'order.id': order.id,
        'execution.id': executionId,
      },
    },
    async span => {
      try {
        // All nested function calls will inherit this span context
        await _validateOrder(order);
        const items = await _prepareItems(order.items);
        const payment = await _processPayment(order.payment);
        const shipment = await _arrangeShipping(items, order.address);
        await _sendConfirmation(order.customer, shipment);

        return { orderId: order.id, status: 'completed' };
      } catch (error) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error.message,
        });
        throw error;
      }
    }
  );
}

// Nested functions with their own spans, maintaining the parent context
function _validateOrder(order) {
  return telemetry.startActiveSpan(
    '_validateOrder',
    { attributes: { 'order.id': order.id } },
    async () => {
      // Implementation
    }
  );
}

function _prepareItems(items) {
  return telemetry.startActiveSpan(
    '_prepareItems',
    { attributes: { 'items.count': items.length } },
    async () => {
      // Implementation
      return processedItems;
    }
  );
}

// And so on for other methods...
```

#### Key Points When Refactoring Existing Code:

1. **Start with the Outermost Function**:

   - Begin by wrapping the top-level function with `startActiveSpan`
   - This creates the parent span that all nested calls will inherit from

2. **Convert Direct Function Calls to Private Methods**:

   - Refactor inline function calls into separate private methods (prefixed with `_`)
   - This makes it easier to add tracing to each step

3. **Use Consistent Context Propagation**:

   - Ensure each nested function uses `startActiveSpan` rather than just `wrapWithSpan`
   - This properly maintains the parent-child relationship in the trace

4. **Preserve the Original API**:

   - Keep the original function signatures when adding tracing
   - This ensures backward compatibility with existing code

5. **Handle Asynchronous Operations**:
   - Convert synchronous functions to asynchronous (Promise-based) when adding tracing
   - Use async/await for cleaner code flow

For examples of converted code, see how we've refactored the `reportGenerationJob.js` and implemented the nested spans
in `notificationService.js`.

## Examples From This Project

### Example 1: Data Backup Job

The data backup job demonstrates how to implement tracing in a scheduled job with multiple steps:

#### Key Implementation Details:

```javascript
// Simplified version of the implementation in src/jobs/dataBackupJob.js

// Top-level function that creates the parent span
function performBackup() {
  const executionId = uuid.v4();

  return telemetry.startActiveSpan(
    'performBackup',
    { attributes: { 'execution.id': executionId } },
    async span => {
      try {
        loggingService.info(`Starting scheduled data backup [execution: ${executionId}]...`);

        // Call nested functions that create child spans
        const backupId = await _createBackupData();
        const users = await _notifyAdmins(backupId);

        return { backupId, notifiedUsers: users };
      } catch (error) {
        // Record error in the span
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: error.message,
        });
        loggingService.error(`Backup failed: ${error.message}`);
        throw error;
      }
    }
  );
}

// Child function that creates its own span as part of the trace
function _createBackupData() {
  return telemetry.startActiveSpan('_createBackupData', {}, async () => {
    // Implementation details
    return backupId;
  });
}

// Another child function with its own span
function _notifyAdmins(backupId) {
  return telemetry.startActiveSpan(
    '_notifyAdmins',
    { attributes: { 'backup.id': backupId } },
    async () => {
      // Implementation details
      return notifiedUsers;
    }
  );
}
```

### Example 2: Notification Service

The notification service demonstrates how to implement deep nested spans (5 levels deep):

```javascript
// Simplified version from src/services/notificationService.js

// Level 1 - Entry point function
function sendNotification(userId, message, options = {}) {
  return telemetry.startActiveSpan(
    'sendNotification',
    { attributes: { userId, messageType: options.type || 'standard' } },
    async () => {
      // Level 2 - Prepare content
      const content = await _prepareNotificationContent(userId, message, options);

      // Level 3 - Get user preferences
      const prefs = await _getUserNotificationPreferences(userId);

      // Level 4 - Get device info
      const deviceInfo = await _getUserDeviceInfo(userId, prefs.deviceId);

      // Level 5 - Deliver notification
      return _deliverNotification(
        userId,
        {
          id: uuid.v4(),
          message: content.formattedMessage,
          // Other properties
        },
        prefs.preferredChannel
      );
    }
  );
}

// Each nested function also creates its own span
function _prepareNotificationContent(userId, message, options) {
  return telemetry.startActiveSpan(
    '_prepareNotificationContent',
    { attributes: { userId } },
    async () => {
      // Implementation
      return { formattedMessage: formattedContent };
    }
  );
}

// And so on for other nested functions...
```

When viewed in Jaeger UI, this creates a beautiful hierarchical trace that shows:

1. The overall notification send operation
2. The content preparation step
3. User preference lookup
4. Device information retrieval
5. The actual notification delivery

This structure makes it easy to see where time is spent and identify bottlenecks.

## Visualizing and Analyzing Traces in Jaeger

After implementing OpenTelemetry tracing in your Node.js application, you can use Jaeger to visualize and analyze the
collected traces.

### Accessing the Jaeger UI

1. Start Jaeger using Docker:

   ```bash
   docker-compose up -d
   ```

2. Open the Jaeger UI in your browser:
   ```
   http://localhost:16686
   ```

### Finding and Analyzing Traces

1. **Select Your Service**:

   - In the "Service" dropdown, select your service name (e.g., "service-cronjob-demo")

2. **Filter by Operation**:

   - Use the "Operation" dropdown to filter for specific operations (e.g., "performBackup", "sendNotification")
   - You can also search for traces containing specific tags or attributes

3. **Analyze Trace Hierarchy**:

   - Click on a trace to see the detailed view
   - The hierarchical view shows parent-child relationships between spans
   - Spans are color-coded based on their duration

4. **Identifying Performance Issues**:
   - Look for spans with long durations (they appear wider in the timeline)
   - Check for unexpected gaps between spans
   - Examine spans with error statuses (typically shown in red)

### Example: GenerateUsageReport Chain Analysis

![Notification Chain Trace Example](./img/img.png)

This visualization shows:

- The total time to send a notification
- Where most of the time is spent (e.g., in database operations, external API calls)
- Any errors that occurred during processing
- The parent-child relationships between all operations

### Troubleshooting with Traces

1. **Error Analysis**:

   - Filter for traces with errors to identify failure patterns
   - Examine error attributes to understand the root cause

2. **Performance Optimization**:

   - Identify the slowest spans in your application
   - Focus optimization efforts on the most time-consuming operations

3. **End-to-End Visibility**:
   - Follow a request across multiple services
   - Understand the complete flow of operations

## Clean Code Principles

This project follows clean code principles as recommended by Robert C. Martin (Uncle Bob). The following practices are implemented throughout the codebase:

### Private Methods and Public APIs

Private methods are prefixed with an underscore (\_) and only public methods are exposed via `module.exports`. This creates a clear distinction between the public API and internal implementation details.

```javascript
// Private implementation
function _performBackup(executionId) {
  // Implementation details
}

// Public API - wrapped with telemetry
function performBackup(executionId) {
  const execId = executionId || uuidv4();
  return telemetry.wrapWithSpan(() => _performBackup(execId), `performBackup.${execId}`, {
    'backup.type': 'scheduled',
    'backup.job': 'dataBackupJob',
    'backup.execution_id': execId,
  })();
}

// Only expose public methods
module.exports = {
  initBackupJob,
  performBackup,
  CONFIG,
};
```

### Self-Documenting Code

The code is written to be self-explanatory without relying on comments. This is achieved through:

1. **Descriptive Function Names**: Functions are named to clearly indicate what they do
2. **Consistent Naming Conventions**: Similar operations use similar naming patterns
3. **Single Responsibility**: Each function does one thing and does it well

Example from the notification service:

```javascript
function _prepareNotificationContent(userId, message, channel) {
  return new Promise(resolve => {
    const delay = Math.floor(Math.random() * (1500 - 1000 + 1)) + 1000;

    setTimeout(async () => {
      loggingService.info(`Preparing notification content for user ${userId}`);
      const preferences = await _getUserNotificationPreferences(userId);
      const formattedMessage = preferences.useHtml ? `<div>${message}</div>` : message;

      const content = {
        userId,
        originalMessage: message,
        formattedMessage,
        channel,
        timestamp: new Date(),
        templateId: preferences.templateId,
        includeFooter: preferences.includeFooter,
      };

      resolve(content);
    }, delay);
  });
}
```

### Telemetry Integration with Clean Code

The codebase demonstrates how to integrate OpenTelemetry while maintaining clean code principles:

1. **Separation of Concerns**: Core business logic is separated from telemetry instrumentation
2. **Wrapper Functions**: Telemetry is added through wrapper functions that don't pollute the business logic
3. **Meaningful Span Names**: Span names and attributes follow consistent naming conventions

```javascript
// Clean business logic in private function
function _registerUserChannels(userId, channels) {
  userChannels[userId] = { ...(userChannels[userId] || {}), ...channels };
  loggingService.info(`Updated notification channels for user ${userId}`);
  return userChannels[userId];
}

// Telemetry wrapper as public API
const registerUserChannels = telemetry.wrapWithSpan(
  _registerUserChannels,
  'notificationService.registerUserChannels',
  { 'notification.operation': 'registerChannels' }
);
```

### Error Handling

The code implements consistent error handling patterns:

```javascript
async function _sendNotification(userId, message, channel = 'email') {
  try {
    // Implementation...
    return notifications[notificationId];
  } catch (error) {
    loggingService.error(`Failed to send notification: ${error.message}`);
    throw error;
  }
}
```

### Function Structure

Functions follow a consistent structure with initialization at the top, main processing in the middle, and return statements at the end:

```javascript
function _scheduleNotification(userId, message, deliveryTime, channel = 'email') {
  const notificationId = uuidv4();
  const timestamp = new Date();

  notifications[notificationId] = {
    id: notificationId,
    userId,
    message,
    channel,
    timestamp,
    deliveryTime,
    status: 'scheduled',
  };

  loggingService.info(`Notification scheduled for user ${userId} at ${deliveryTime}`);
  return notifications[notificationId];
}
```

By following these clean code principles, the codebase remains maintainable, readable, and self-documenting while still implementing advanced features like OpenTelemetry tracing.

## Clean Code vs. Traditional Approach

This project demonstrates the clean code approach advocated by Robert C. Martin, but it's useful to compare this with more traditional approaches to understand the benefits and trade-offs.

### Traditional Approach (With Comments)

```javascript
/**
 * Send a notification to the specified user
 *
 * @param {string} userId - The ID of the user to send the notification to
 * @param {string} message - The notification message content
 * @param {string} [channel='email'] - The channel to send the notification through (email, sms, push)
 * @returns {Object} The notification object with status information
 * @throws {Error} If the notification fails to send
 */
async function sendNotification(userId, message, channel = 'email') {
  // Generate a unique ID for this notification
  const notificationId = uuidv4();

  // Record the current time
  const timestamp = new Date();

  // Format the message based on user preferences
  const content = await prepareNotificationContent(userId, message, channel);

  // Create the notification record
  notifications[notificationId] = {
    id: notificationId,
    userId,
    message: content.formattedMessage,
    originalMessage: message,
    channel,
    timestamp,
    status: 'processing',
  };

  // Log that we've created the notification
  loggingService.logInfo(`Created notification ${notificationId} for user ${userId}`);

  // Deliver the notification through the appropriate channel
  const deliveryResult = await deliverNotification(userId, notifications[notificationId], channel);

  // Update the notification status
  notifications[notificationId].status = 'sent';
  notifications[notificationId].deliveredAt = deliveryResult.timestamp;

  return notifications[notificationId];
}
```

### Clean Code Approach (Self-Documenting)

```javascript
function _sendNotification(userId, message, channel = 'email') {
  try {
    const notificationId = uuidv4();
    const timestamp = new Date();
    const content = await _prepareNotificationContent(userId, message, channel);

    notifications[notificationId] = {
      id: notificationId,
      userId,
      message: content.formattedMessage,
      originalMessage: message,
      channel,
      timestamp,
      status: 'processing',
    };

    loggingService.info(`Notification created for user ${userId} via ${channel}: ${notificationId}`);

    const deliveryResult = await _deliverNotification(
      userId,
      notifications[notificationId],
      channel
    );

    notifications[notificationId].status = 'sent';
    notifications[notificationId].deliveredAt = deliveryResult.timestamp;

    return notifications[notificationId];
  } catch (error) {
    loggingService.error(`Failed to send notification: ${error.message}`);
    throw error;
  }
}

const sendNotification = telemetry.wrapWithSpan(
  _sendNotification,
  'notificationService.sendNotification',
  { 'notification.operation': 'send' }
);
```

### Key Differences

1. **Comments vs. Self-Documentation**

   - Traditional: Uses JSDoc comments to explain parameters, return values, and function purpose
   - Clean Code: Uses descriptive function and variable names, making the purpose clear without comments

2. **Error Handling**

   - Traditional: May not consistently handle errors
   - Clean Code: Uses consistent try/catch blocks with proper logging

3. **Function Size and Responsibility**

   - Traditional: May have larger functions with multiple responsibilities
   - Clean Code: Functions are smaller with single responsibilities, often delegated to helper functions

4. **API Design**
   - Traditional: May expose implementation details directly
   - Clean Code: Separates private implementation (\_function) from public API (wrapper function)

### When to Use Each Approach

**Traditional Approach Works Well For:**

- Public APIs where external developers need documentation
- Complex algorithms where the "why" isn't obvious from the code
- Teams with varying experience levels who benefit from explicit guidance

**Clean Code Approach Works Well For:**

- Internal application code maintained by a consistent team
- Code that changes frequently
- Teams that value maintainability and readability
- Systems where testing is a priority

In this project, we've opted for the clean code approach to demonstrate how even complex systems with features like hierarchical tracing can be implemented in a readable, maintainable way without relying on comments.
